/**********************************************************************************************************************************************************
* 文 件 名：LCD.c
* 功    能：SO12864FPD-13ASBE(3S)点阵图形液晶模块（ST7565P）驱动头文件。
* 硬件连接：SO12864FPD-13ASBE(3S)点阵图形液晶模块（ST7565P）与CC2530的硬件连接关系如下所示：
*
*
*           SO12864FPD-13ASBE(3S)                CC2530
*
*               SCL(PIN7)                         P1.5
*               SID(PIN8)                         P1.6
*               A0(PIN14)                         P1.7
*               CSn(PIN12)                        P1.4
*               RESETn(PIN13)                     P2.0
*               VDD(PIN9)
*               VSS(PIN10)
*               LED+(PIN11)
* 版    本：V1.0
* 作    者：WUXIANHAI
* 日    期：2011.1.19
* 奥尔斯电子主页：www.ourselec.com
**********************************************************************************************************************************************************/

#include "hal.h"
#include "LCD.h"


//#define LCM_13                                             // 若使用13的屏，使用该宏定义，否则屏蔽该宏定义

UINT8  DisplayBuffer[8][128];                              // 显示缓冲区

/* 5*7字体定义 */
/*===============================*/
__code const UINT8 FONT5x7ASCII[][8] =
{
/* 空格 */
  {
   ________,
   ________,
   ________,
   ________,
   ________,
   ________,
   ________,
   ________}

/*  !  */
 ,{
   X_______,
   X_______,
   X_______,
   X_______,
   X_______,
   ________,
   X_______,
   ________}


/*  "  */
 ,{
   X_X_____,
   X_X_____,
   X_X_____,
   ________,
   ________,
   ________,
   ________,
   ________}

/* #  */
 ,{
   _X_X____,
   _X_X____,
   XXXXX___,
   _X_X____,
   XXXXX___,
   _X_X____,
   _X_X____,
   ________}

/*  $  */
 ,{
   __X_____,
   _XXXX___,
   X_X_____,
   _XXX____,
   __X_X___,
   XXXX____,
   __X_____}

/*  %  */
 ,{
   XX______,
   XX__X___,
   ___X____,
   __X_____,
   _X______,
   X__XX___,
   ___XX___,
   ________}

/*  &  */
 ,{
   _XX_____,
   X__X____,
   X_X_____,
   _X______,
   X_X_X___,
   X__X____,
   _XX_X___,
   ________}

/*  '  */
 ,{
   XX______,
   _X______,
   X_______,
   ________,
   ________,
   ________,
   ________,
   ________}

/*  (  */
 ,{
   __X_____,
   _X______,
   X_______,
   X_______,
   X_______,
   _X______,
   __X_____,
   ________}

/*  )  */
 ,{
   X_______,
   _X______,
   __X_____,
   __X_____,
   __X_____,
   _X______,
   X_______,
   ________}

/*  *  */
 ,{
   ________,
   _X_X____,
   __X_____,
   XXXXX___,
   __X_____,
   _X_X____,
   ________,
   ________}

 ,{
   ________,
   __X_____,
   __X_____,
   XXXXX___,
   __X_____,
   __X_____,
   ________,
   ________}

 ,{
   ________,
   ________,
   ________,
   ________,
   ________,
   XX______,
   _X______,
   X_______}

 ,{
   ________,
   ________,
   ________,
   XXXXX___,
   ________,
   ________,
   ________,
   ________}

 ,{
   ________,
   ________,
   ________,
   ________,
   ________,
   XX______,
   XX______,
   ________}

 ,{
   ________,
   ____X___,
   ___X____,
   __X_____,
   _X______,
   X_______,
   ________,
   ________}

/* 0 */
 ,{
   _XXX____,
   X___X___,
   X__XX___,
   X_X_X___,
   XX__X___,
   X___X___,
   _XXX____,
   ________}

/* 1 */
 ,{
   __X_____,
   _XX_____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   _XXX____,
   ________}

/* 2 */
 ,{
   _XXX____,
   X___X___,
   ____X___,
   __XX____,
   _X______,
   X_______,
   XXXXX___,
   ________}

/* 3 */
 ,{
   _XXX____,
   X___X___,
   ____X___,
   __XX____,
   ____X___,
   X___X___,
   _XXX____,
   ________}

/* 4 */
 ,{
   ___X____,
   __XX____,
   _X_X____,
   X__X____,
   XXXXX___,
   ___X____,
   ___X____,
   ________}

/* 5 */
 ,{
   XXXXX___,
   X_______,
   XXXX____,
   ____X___,
   ____X___,
   X___X___,
   _XXX____,
   ________}

/* 6 */
 ,{
   __XX____,
   _X______,
   X_______,
   XXXX____,
   X___X___,
   X___X___,
   _XXX____,
   ________}

/* 7 */
 ,{
   XXXXX___,
   ____X___,
   ___X____,
   __X_____,
   _X______,
   _X______,
   _X______,
   ________}

/* 8 */
 ,{
   _XXX____,
   X___X___,
   X___X___,
   _XXX____,
   X___X___,
   X___X___,
   _XXX____,
   ________}

/* 9 */
 ,{
   _XXX____,
   X___X___,
   X___X___,
   _XXXX___,
   ____X___,
   ___X____,
   _XX_____,
   ________}

/* ':' 3a */
 ,{
   ________,
   XX______,
   XX______,
   ________,
   XX______,
   XX______,
   ________,
   ________}

/* ';' 3b */
 ,{
   ________,
   ________,
   XX______,
   XX______,
   ________,
   XX______,
   _X______,
   X_______}


/* '<' 3c */
 ,{
   ___X____,
   __X_____,
   _X______,
   X_______,
   _X______,
   __X_____,
   ___X____,
   ________}

/* '=' 3d */
 ,{
   ________,
   ________,
   XXXXX___,
   ________,
   XXXXX___,
   ________,
   ________,
   ________}

/* '>' */
 ,{
   X_______,
   _X______,
   __X_____,
   ___X____,
   __X_____,
   _X______,
   X_______,
   ________}

/* '?' */
 ,{
   _XXX____,
   X___X___,
   ____X___,
   ___X____,
   __X_____,
   ________,
   __X_____,
   ________}

/* @ */
 ,{
   _XXX____,
   X___X___,
   ____X___,
   _XX_X___,
   X_X_X___,
   X_X_X___,
   _XXX____,
   ________}

/* A */
 ,{
   _XXX____,
   X___X___,
   X___X___,
   XXXXX___,
   X___X___,
   X___X___,
   X___X___,
   ________}

/* B */
 ,{
   XXXX____,
   X___X___,
   X___X___,
   XXXX____,
   X___X___,
   X___X___,
   XXXX____,
   ________}

/* C */
 ,{
   _XXX____,
   X___X___,
   X_______,
   X_______,
   X_______,
   X___X___,
   _XXX____,
   ________}

/* D */
 ,{
   XXX_____,
   X__X____,
   X___X___,
   X___X___,
   X___X___,
   X__X____,
   XXX_____,
   ________}

/* E */
 ,{
   XXXXX___,
   X_______,
   X_______,
   XXXX____,
   X_______,
   X_______,
   XXXXX___,
   ________}

/* F */
 ,{
   XXXXX___,
   X_______,
   X_______,
   XXXX____,
   X_______,
   X_______,
   X_______,
   ________}

/* G */
 ,{
   _XXX____,
   X___X___,
   X_______,
   X_______,
   X__XX___,
   X___X___,
   _XXXX___,
   ________}

/* H */
 ,{
   X___X___,
   X___X___,
   X___X___,
   XXXXX___,
   X___X___,
   X___X___,
   X___X___,
   ________}

/* I */
 ,{
   XXX_____,
   _X______,
   _X______,
   _X______,
   _X______,
   _X______,
   XXX_____,
   ________}

/* J */
 ,{
   __XXX___,
   ___X____,
   ___X____,
   ___X____,
   ___X____,
   X__X____,
   _XX_____,
   ________}

/* K */
 ,{
   X___X___,
   X__X____,
   X_X_____,
   XX______,
   X_X_____,
   X__X____,
   X___X___,
   ________}

/* L */
 ,{
   X_______,
   X_______,
   X_______,
   X_______,
   X_______,
   X_______,
   XXXXX___,
   ________}

/* M */
 ,{
   X___X___,
   XX_XX___,
   X_X_X___,
   X_X_X___,
   X___X___,
   X___X___,
   X___X___,
   ________}

/* N */
 ,{
   X___X___,
   X___X___,
   XX__X___,
   X_X_X___,
   X__XX___,
   X___X___,
   X___X___,
   ________}

/* O */
 ,{
   _XXX____,
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   _XXX____,
   ________}

/* P */
 ,{
   XXXX____,
   X___X___,
   X___X___,
   XXXX____,
   X_______,
   X_______,
   X_______,
   ________}

/* Q */
 ,{
   _XXX____,
   X___X___,
   X___X___,
   X___X___,
   X_X_X___,
   X__X____,
   _XX_X___,
   ________}

/* R */
 ,{
   XXXX____,
   X___X___,
   X___X___,
   XXXX____,
   X_X_____,
   X__X____,
   X___X___,
   ________}

/* S */
 ,{
   _XXX____,
   X___X___,
   X_______,
   _XXX____,
   ____X___,
   X___X___,
   _XXX____,
   ________}

/* T */
 ,{
   XXXXX___,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   ________}

/* U */
 ,{
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   _XXX____,
   ________}

/* V */
 ,{
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   X___X___,
   _X_X____,
   __X_____,
   ________}

/* W */
 ,{
   X___X___,
   X___X___,
   X___X___,
   X_X_X___,
   X_X_X___,
   X_X_X___,
   _X_X____,
   ________}

/* X */
 ,{
   X___X___,
   X___X___,
   _X_X____,
   __X_____,
   _X_X____,
   X___X___,
   X___X___,
   ________}

/* Y */
 ,{
   X___X___,
   X___X___,
   _X_X____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   ________}

/* Z */
 ,{
   XXXXX___,
   ____X___,
   ___X____,
   __X_____,
   _X______,
   X_______,
   XXXXX___,
   ________}

/* 5b */
 ,{
   XXX_____,
   X_______,
   X_______,
   X_______,
   X_______,
   X_______,
   XXX_____,
   ________}

/* 5c */
 ,{
   ________,
   X_______,
   _X______,
   __X_____,
   ___X____,
   ____X___,
   ________,
   ________}

/* 5d */
 ,{
   XXX_____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   XXX_____,
   ________}

/* 5e */
 ,{
   __X_____,
   _X_X____,
   X___X___,
   ________,
   ________,
   ________,
   ________,
   ________}

/* 5f */
 ,{
   ________,
   ________,
   ________,
   ________,
   ________,
   ________,
   ________,
   XXXXX___}

/* 60 */
 ,{
   X_______,
   _X______,
   __X_____,
   ________,
   ________,
   ________,
   ________,
   ________}

/* a */
 ,{
   ________,
   ________,
   _XXX____,
   ____X___,
   _XXXX___,
   X___X___,
   _XXXX___,
   ________}

/* b */
 ,{
   X_______,
   X_______,
   X_XX____,
   XX__X___,
   X___X___,
   X___X___,
   XXXX____,
   ________}

/* c */
 ,{
   ________,
   ________,
   _XX_____,
   X__X____,
   X_______,
   X__X____,
   _XX_____,
   ________}

/* d */
 ,{
   ____X___,
   ____X___,
   _XX_X___,
   X__XX___,
   X___X___,
   X___X___,
   _XXXX___,
   ________}

/* e */
 ,{
   ________,
   ________,
   _XXX____,
   X___X___,
   XXXXX___,
   X_______,
   _XXX____,
   ________}

/* f */
 ,{
   __X_____,
   _X_X____,
   _X______,
   XXX_____,
   _X______,
   _X______,
   _X______,
   ________}

/* g */
 ,{
   ________,
   ________,
   _XXXX___,
   X___X___,
   X___X___,
   _XXXX___,
   ____X___,
   _XXX____}

/* h */
 ,{
   X_______,
   X_______,
   X_XX____,
   XX__X___,
   X___X___,
   X___X___,
   X___X___,
   ________}

/* i */
 ,{
   _X______,
   ________,
   _X______,
   _X______,
   _X______,
   _X______,
   _X______,
   ________}

/* j */
 ,{
   __X_____,
   ________,
   _XX_____,
   __X_____,
   __X_____,
   __X_____,
   __X_____,
   XX______}

/* k */
 ,{
   X_______,
   X_______,
   X__X____,
   X_X_____,
   XX______,
   X_X_____,
   X__X____,
   ________}

/* l */
 ,{
   XX______,
   _X______,
   _X______,
   _X______,
   _X______,
   _X______,
   XXX_____,
   ________}

/* m */
 ,{
   ________,
   ________,
   XX_X____,
   X_X_X___,
   X_X_X___,
   X___X___,
   X___X___,
   ________}

/* n */
 ,{
   ________,
   ________,
   X_XX____,
   XX_X____,
   X__X____,
   X__X____,
   X__X____,
   ________}

/* o */
 ,{
   ________,
   ________,
   _XX_____,
   X__X____,
   X__X____,
   X__X____,
   _XX_____,
   ________}

/* p */
 ,{
   ________,
   ________,
   XXX_____,
   X__X____,
   X__X____,
   XXX_____,
   X_______,
   X_______}

/* q */
 ,{
   ________,
   ________,
   _XXX____,
   X__X____,
   X__X____,
   _XXX____,
   ___X____,
   ___X____}

/* r */
 ,{
   ________,
   ________,
   _X_X____,
   _XX_____,
   _X______,
   _X______,
   _X______,
   ________}

/* s */
 ,{
   ________,
   ________,
   _XXX____,
   X_______,
   _XX_____,
   ___X____,
   XXX_____,
   ________}

/* t */
 ,{
   _X______,
   _X______,
   XXX_____,
   _X______,
   _X______,
   _X______,
   _XX_____,
   ________}

/* u */
 ,{
   ________,
   ________,
   X__X____,
   X__X____,
   X__X____,
   X__X____,
   _XXX____,
   ________}

/* v */
 ,{
   ________,
   ________,
   X___X___,
   X___X___,
   X___X___,
   _X_X____,
   __X_____,
   ________}

/* w */
 ,{
   ________,
   ________,
   X___X___,
   X___X___,
   X_X_X___,
   X_X_X___,
   _X_X____,
   ________}

/* X */
 ,{
   ________,
   ________,
   X___X___,
   _X_X____,
   __X_____,
   _X_X____,
   X___X___,
   ________}

/* y */
 ,{
   ________,
   ________,
   X__X____,
   X__X____,
   X__X____,
   _XXX____,
   ___X____,
   _XX_____}

/* z */
 ,{
   ________,
   ________,
   XXXXX___,
   ___X____,
   __X_____,
   _X______,
   XXXXX___,
   ________}

/* 0x7b */
 ,{
   __X_____,
   _X______,
   _X______,
   X_______,
   _X______,
   _X______,
   __X_____,
   ________}

/* 0x7c */
 ,{
   _X______,
   _X______,
   _X______,
   _X______,
   _X______,
   _X______,
   _X______,
   ________}

/* 0x7d */
 ,{
   X_______,
   _X______,
   _X______,
   __X_____,
   _X______,
   _X______,
   X_______,
   ________}

/* 0x7e */
 ,{
   _XX_X___,
   X__X____,
   ________,
   ________,
   ________,
   ________,
   ________,
   ________}

/* 0x7f */
 ,{
   XXXXX___,
   XXXXX___,
   XXXXX___,
   XXXXX___,
   XXXXX___,
   XXXXX___,
   XXXXX___,
   ________}

};
/*===============================*/

/********************************************************************************************
* 函数名称：LCM_DataSend()
* 功    能：串行模式发送数据
* 入口参数：data    要发送的数据
* 出口参数：无
*********************************************************************************************/
void LCM_DataSend(UINT8 data)
{
  UINT8 s,temp,i;

  L_LCM_SCL();
  s = data;

  for(i=8;i>0;i--)
    {
      L_LCM_SCL();
      asm("nop");
      asm("nop");
      temp = s & 0x80;
      if(temp)
        {H_LCM_SID();}
      else
        {L_LCM_SID();}
      H_LCM_SCL();
      s = s << 1;
    }
}

/********************************************************************************************
* 函数名称：LCM_WriteCMD()
* 功    能：写命令
* 入口参数：command    命令
* 出口参数：无
*********************************************************************************************/
void LCM_WriteCMD(UINT8 command)
{
  L_LCM_A0();
  L_LCM_CSn();
  LCM_DataSend(command);
  asm("nop");
  H_LCM_CSn();
}

/********************************************************************************************
* 函数名称：LCM_WriteData()
* 功    能：写数据
* 入口参数：data    数据
* 出口参数：无
*********************************************************************************************/
void LCM_WriteData(UINT8 data)
{
  H_LCM_A0();
  L_LCM_CSn();
  LCM_DataSend(data);
  asm("nop");
  H_LCM_CSn();
}

/********************************************************************************************
* 函数名称：LCM_Init()
* 功    能：SO12864FPD-13ASBE(3S)初始化
* 入口参数：无
* 出口参数：无
*********************************************************************************************/
void LCM_Init(void)
{
  IO_DIR_PORT_PIN(1, 7, IO_OUT);                                   // 设置P1.7方向为输出
  IO_DIR_PORT_PIN(1, 6, IO_OUT);                                   // 设置P1.6方向为输出
  IO_DIR_PORT_PIN(2, 0, IO_OUT);                                   // 设置P2.0方向为输出
  IO_DIR_PORT_PIN(1, 5, IO_OUT);                                   // 设置P1.5方向为输出
  IO_DIR_PORT_PIN(1, 4, IO_OUT);                                   // 设置P1.4方向为输出

  L_LCM_RESETn();
  asm("nop");
  asm("nop");
  H_LCM_RESETn();

  LCM_WriteCMD(LCM_CMD_DisplayON);                                 // 显示开

#ifdef LCM_13

  // 使用13的屏幕
  /*****************************************/
  LCM_WriteCMD(LCM_CMD_DisplayStartLineSet(32));                   // 显示起始行为LCM的最顶部（即显示RAM行地址32）
  /*****************************************/

#else

  // 使用14的屏幕
  /*****************************************/
  LCM_WriteCMD(LCM_CMD_DisplayStartLineSet(64));                   // 显示起始行为LCM的最顶部（即显示RAM行地址64）
  /*****************************************/

#endif

#ifdef LCM_13

  // 使用13的屏幕
  /*****************************************/
  LCM_WriteCMD(LCM_CMD_ADC_Normal);                                // 模块正向安装，列地址从左到右为0~127
  /*****************************************/

#else

  // 使用14的屏幕
  /*****************************************/
  LCM_WriteCMD(LCM_CMD_ADC_Reverse);                               // 模块反向安装，列地址从左到右为131~4
  /*****************************************/

#endif

  LCM_WriteCMD(LCM_CMD_Display_Normal);                            // 正常显示
  LCM_WriteCMD(LCM_CMD_DisplayAllPointsOFF);                       // clear
  LCM_WriteCMD(LCM_CMD_LCDBias_1_9);                               // LCD的偏压比1/9(本模块固定为1/9)

#ifdef LCM_13

  // 使用13的屏幕
  /*****************************************/
  LCM_WriteCMD(LCM_CMD_CommonOutputMode_Reverse);                  // 模块的上端（注意：并不是指LCM最顶部）为第0行，往下依次为63，62，......2，1
                                                                   // 当模块正向安装时使用
  /*****************************************/

#else

  // 使用14的屏幕
  /*****************************************/
  LCM_WriteCMD(LCM_CMD_CommonOutputMode_Normal);                   // 模块的下端（注意：并不是指LCM最底部）为第0行，往上依次为63，62，......2，1
                                                                   // 当模块反向安装时使用
  /*****************************************/

#endif

  LCM_WriteCMD(LCM_CMD_PowerControl);                              // 开关内部电路的电源。本模块应设置成0x2F
  LCM_WriteCMD(LCM_CMD_V0Set(5));                                  // 粗调对比度

  /* 细调对比度 */
  LCM_WriteCMD(LCM_CMD_ElectronicVolumeMode);
  LCM_WriteCMD(LCM_CMD_ElectronicVolumeSet(22));

  /* Static Indicator OFF */
  LCM_WriteCMD(LCM_CMD_StaticIndicatorOFF);
  LCM_WriteCMD(LCM_CMD_StaticIndicatorOFF_Feed);
}

/********************************************************************************************
* 函数名称：LCM_ShowBitmap12864()
* 功    能：在SO12864FPD-13ASBE(3S)上显示一幅128*64点阵单色位图。
* 入口参数：bitmap12864  128*64点阵单色位图数据
* 出口参数：无
* 注    意：位图数据应该纵向取模，字节倒序。
*********************************************************************************************/
void LCM_ShowBitmap12864(UINT8 *bitmap12864)
{
  UINT8 seg;
  UINT8 page;

  for(page=LCM_CMD_PageAddressSet(0);page<=LCM_CMD_PageAddressSet(8);page++) // 写页地址共8 页 0xb0----0xb8
    {
      LCM_WriteCMD(page);

#ifdef LCM_13

      //使用13的屏幕
      /*****************************************/
      LCM_WriteCMD(LCM_CMD_ColumnAddressHSet(0));                            // 列地址，高低字节两次写入，从第0 列开始
      LCM_WriteCMD(LCM_CMD_ColumnAddressLSet(0));
      /*****************************************/

#else

      //使用14的屏幕
      /*****************************************/
      LCM_WriteCMD(LCM_CMD_ColumnAddressHSet(4));                            // 列地址，高低字节两次写入，从第4 列开始
      LCM_WriteCMD(LCM_CMD_ColumnAddressLSet(4));
      /*****************************************/

#endif

      for(seg=0;seg<128;seg++)                                               // 写128 列
        { LCM_WriteData(*bitmap12864++); }
    }
}

/********************************************************************************************
* 函数名称：LCM_Refresh()
* 功    能：将显示缓冲区中的数据刷新到SO12864FPD-13ASBE(3S)上显示。
* 入口参数：无
* 出口参数：无
*********************************************************************************************/
void LCM_Refresh(void)
{
  LCM_ShowBitmap12864((UINT8 *)DisplayBuffer);
}

/******************************************************************************************************************
* 函数名称：WriteByteToDisplayBuffer()
* 功    能：向显示缓冲区中指定点写一字节数据
* 入口参数：x 		指定点横坐标值(0-127)
*           y           指定点纵坐标值(0-63)
*           data	所要写的数据
* 出口参数：无
*******************************************************************************************************************/
void WriteByteToDisplayBuffer(UINT8 x, UINT8 y, UINT8 data)
{
  x&=0x7f; y&=0x3f;	                                           // 参数过滤		

  /* 更新显示缓冲区 */
  /*==========================================================================*/
  y = y>>3;                                                        // 根据y坐标值算出指定页
  DisplayBuffer[y][x] = data;
  /*==========================================================================*/
}

/******************************************************************************************************************
* 函数名称：ReadByteFromDisplayBuffer()
* 功    能：从显示缓冲区中指定点读一字节数据
* 入口参数：x 		指定点横坐标值(0-127)
*           y           指定点纵坐标值(0-63)
* 出口参数：返回该点上的字节数据。
*******************************************************************************************************************/
UINT8 ReadByteFromDisplayBuffer(UINT8 x, UINT8 y)
{
  x&=0x7f; y&=0x3f;	                                           // 参数过滤

  /* 返回显示缓冲区指定点上的数据 */
  /*==========================================================================*/
  y = y>>3;                                                        // 根据y坐标值算出指定页
  return (DisplayBuffer[y][x]);                                    // 返回显示缓冲区指定点上的数据
  /*==========================================================================*/
 }

/******************************************************************************************************************
* 函数名称：GUI_FillScreen()
* 功    能：全屏填充。填充显示缓冲区。
* 入口参数：data      填充的数据
* 出口参数：无
*******************************************************************************************************************/
void GUI_FillScreen(UINT8 data)
{
  UINT8 i,j;

  /* 更新显示缓冲区 */
  /*==============================================*/
  for(i=0;i<128;i++)
  {
    for(j=0;j<64;j++)
    {
      WriteByteToDisplayBuffer(i,j,data);
    }
  }
  /*==============================================*/
}

/******************************************************************************************************************
* 函数名称：GUI_ClearScreen()
* 功    能：清屏。清除显示缓冲区。
* 入口参数：无
* 出口参数：无
*******************************************************************************************************************/
void GUI_ClearScreen(void)
{
  GUI_FillScreen(0x00);	                                           // 显示缓冲区清0
}

/******************************************************************************************************************
* 函数名称：GUI_Init()
* 功    能：初始化GUI。
* 入口参数：无
* 出口参数：无
*******************************************************************************************************************/
void GUI_Init(void)
{
   LCM_Init();                                                     // LCM初始化
   GUI_ClearScreen();	                                           // 清屏
   LCM_Refresh();                                                  // 将显示缓冲区的内容刷新到LCM12864
}

UINT8 const DEC_HEX_TAB[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};  // 定义数据转换表
/******************************************************************************************************************
* 函数名称：GUI_Point()
* 功    能：在LCM12864指定位置对应的显示缓冲区画点。
* 入口参数：x        指定点所在列的位置
*           y        指定点所在行的位置
*           color    对于黑白色或蓝白色LCM12864，为0时灭，为1时显示
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
UINT8  GUI_Point(UINT8 x, UINT8 y, UINT8 color)
{
  UINT8   bak;

  if(x>=128)  return(0); if(y>=64)   return(0);                    // 参数判断，出错返回0

  //x=x+4;

  /* 设置指定点为1或0 */
  /*===========================================================================================*/
  bak = ReadByteFromDisplayBuffer(x,y);                            // 从显示缓冲区读取指定点的1字节数据
  if(0==color)                                                     // 若让该点灭
   {
     bak &= (~DEC_HEX_TAB[y&0x07]);                                // 该点对应的位复位，而其他7位不变
   }
  else                                                             // 若让该点亮
   {
     bak |= DEC_HEX_TAB[y&0x07];                                   // 该点对应的位置位，而其他7位不变
   }

  WriteByteToDisplayBuffer(x, y, bak);                             // 向LCM12864指定点对应的显示缓冲区写一字节数据
  /*===========================================================================================*/

  return(1);                                                       // 操作成功返回1
}

/******************************************************************************************************************
* 函数名称：GUI_ReadPoint()
* 功    能：在LCM12864指定位置对应的显示缓冲区读取指定点的颜色。
* 入口参数：x        指定点所在列的位置
*           y        指定点所在行的位置
*           ret      保存颜色值的指针
* 出口参数：返回0表示指定地址超出缓冲区范围。
* 说    明：对于单色，设置ret的d0位为1或0
*******************************************************************************************************************/
UINT8  GUI_ReadPoint(UINT8 x, UINT8 y, UINT8 *ret)
{
  UINT8  bak;

  if(x>=128)  return(0); if(y>=64)   return(0);                    // 参数判断，出错返回0

  //x=x+4;

  /* 读取指定点的颜色值 */
  /*===========================================================================================*/
  bak = ReadByteFromDisplayBuffer(x,y);                            // 读取指定点的1字节数据
  if( (bak & (DEC_HEX_TAB[y&0x07])) == 0 )                         // 若指定点的颜色值为0
     *ret = 0x00;                                                  // 保存该颜色值
  else                                                             // 若指定点的颜色值为1
     *ret = 0x01;                                                  // 保存该颜色值
  /*===========================================================================================*/

  return(1);                                                       // 操作成功返回1
}

/******************************************************************************************************************
* 函数名称：GUI_HLine()
* 功    能：在LCM12864的显示缓冲区画水平线。
* 入口参数：x0		水平线起点所在列的位置
*           y0		水平线起点所在行的位置
*           x1      水平线终点所在列的位置
*           color	对于黑白色或蓝白色LCM12864，为0时灭，为1时显示
* 出口参数：无
*******************************************************************************************************************/
void  GUI_HLine(UINT8 x0, UINT8 y0, UINT8 x1, UINT8 color)
{
  UINT8  bak;

  if(x0>x1) {bak = x1;x1 = x0; x0 = bak;}        // 对x0、x1大小进行排列，以便画图

  /* 逐点显示，描出水平线 */
  /*==========================*/
  do
   {
     GUI_Point(x0, y0, color);		
     x0++;
   }while(x1>=x0);
  /*==========================*/

}

/******************************************************************************************************************
* 函数名称：GUI_RLine()
* 功    能：在LCM12864的显示缓冲区画竖直线。
* 入口参数：x0		垂直线起点所在列的位置
*           y0		垂直线起点所在行的位置
*           y1      垂直线终点所在行的位置
*           color	对于黑白色或蓝白色LCM12864，为0时灭，为1时显示
* 出口参数：无
*******************************************************************************************************************/
void  GUI_RLine(UINT8 x0, UINT8 y0, UINT8 y1, UINT8 color)
{
  UINT8  bak;

  if(y0>y1){bak = y1;y1 = y0;y0 = bak;}          // 对y0、y1大小进行排列，以便画图

  /* 逐点显示，描出竖直线 */
  /*==========================*/
  do
   {
     GUI_Point(x0, y0, color);		
     y0++;
   }while(y1>=y0);
  /*==========================*/
}

/******************************************************************************************************************
* 函数名称：GUI_Rectangle()
* 功    能：画矩形。
* 入口参数：x0		矩形左上角的x坐标值
*           y0		矩形左上角的y坐标值
*           x1      矩形右下角的x坐标值
*           y1      矩形右下角的y坐标值
*           color	对于黑白色或蓝白色LCM12864，为0时灭，为1时显示
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_Rectangle(UINT8 x0, UINT8 y0, UINT8 x1, UINT8 y1, UINT8 color)
{
  GUI_HLine(x0, y0, x1, color);
  GUI_HLine(x0, y1, x1, color);
  GUI_RLine(x0, y0, y1, color);
  GUI_RLine(x1, y0, y1, color);
}

/******************************************************************************************************************
* 函数名称：GUI_RectangleFill()
* 功    能：填充矩形。画一个填充的矩形，填充色与边框色一样。
* 入口参数：x0		矩形左上角的x坐标值
*           y0		矩形左上角的y坐标值
*           x1      矩形右下角的x坐标值
*           y1      矩形右下角的y坐标值
*           color	对于黑白色或蓝白色LCM12864，为0时灭，为1时显示
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_RectangleFill(UINT8 x0, UINT8 y0, UINT8 x1, UINT8 y1, UINT8 color)
{
  UINT8  tmp;

  /* 先找出矩形左上角与右下角的两个点，保存在(x0,y0)，(x1,y1) */
  /*========================================================================*/
  if(x0>x1) {tmp = x0; x0 = x1; x1 = tmp;} 	     // 若x0>x1，则x0与x1交换
  if(y0>y1)	{tmp = y0; y0 = y1; y1 = tmp;}		 // 若y0>y1，则y0与y1交换
  /*========================================================================*/


  /* 判断是否只是直线 */
  /*========================================================================*/
  if(y0==y1)                                     // 是水平线
   {
     GUI_HLine(x0, y0, x1, color);               // 画出该水平线
     return;                                     // 返回
   }
  if(x0==x1)                                     // 是垂直线
   {
     GUI_RLine(x0, y0, y1, color);               // 画出该垂直线
     return;                                     // 返回
   }
  /*========================================================================*/

  /* 逐行画水平线*/
  /*========================================================================*/
  while(y0<=y1)						
      {
        GUI_HLine(x0, y0, x1, color);	         // 画出当前水平线
        y0++;							         // 下一行
      }
  /*========================================================================*/
}

/* 定义十进制(0-7)==>十六进制位转换表，由于显示点数据是由左到右，所以十六进制位顺序是倒的 */
/*========================================================================================*/
UINT8 const DCB2HEX_TAB[8]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
/*========================================================================================*/

/* 定义前景色及背景色变量，用于ASCII码、汉字、单色位图显示 */
/*=========================================================*/
UINT8   disp_color;                                                // 定义前景色（显示色）变量
UINT8	back_color;                                                // 定义背景色变量
/*=========================================================*/

/******************************************************************************************************************
* 函数名称：GUI_SetColor()
* 功    能：设置显示色及背景色。用于ASCII字符显示及汉字显示。
* 入口参数：color1	显示色的值
*           color2	背景色的值
* 出口参数：无
* 说    明：
*******************************************************************************************************************/
void GUI_SetColor(UINT8 color1, UINT8 color2)
{
  GUI_CopyColor(&disp_color, color1);
  GUI_CopyColor(&back_color, color2);
}

/******************************************************************************************************************
* 函数名称：GUI_GetBackColor()
* 功    能：取得当前背景色。
* 入口参数：bakc        保存颜色的变量地址
* 出口参数：无
* 说    明：
*******************************************************************************************************************/
void GUI_GetBackColor(UINT8  *bakc)
{
  GUI_CopyColor(bakc, back_color);
}

/******************************************************************************************************************
* 函数名称：GUI_GetDispColor()
* 功    能：取得当前前景色（显示色）。
* 入口参数：bakc		保存颜色的变量地址
* 出口参数：无
* 说    明：
*******************************************************************************************************************/
void GUI_GetDispColor(UINT8  *bakc)
{
  GUI_CopyColor(bakc, disp_color);
}

/******************************************************************************************************************
* 函数名称：GUI_ExchangeColor()
* 功    能：交换前景色（显示色）与背景色。用于反相显示。
* 入口参数：无
* 出口参数：无
* 说    明：
*******************************************************************************************************************/
void GUI_ExchangeColor(void)
{
  UINT8  bakc;

  GUI_CopyColor(&bakc, disp_color);
  GUI_CopyColor(&disp_color, back_color);
  GUI_CopyColor(&back_color, bakc);
}


/******************************************************************************************************************
* 函数名称：GUI_LoadLine()
* 功    能：输出单色图形的一行数据。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           dat		要输出显示的数据。:横向取模，字节顺序。
*           no          要显示此行的点个数
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
UINT8 GUI_LoadLine(UINT8 x, UINT8 y, UINT8 *dat, UINT8 no)
{
  UINT8   bit_dat;
  UINT8   i;
  UINT8   bakc;

  /* 参数过滤 */
  /*===========================================================================*/
  if(x>=128) return(0);                                            // x坐标越界，返回0
  if(y>=64)  return(0);                                            // y坐标越界，返回0
  /*===========================================================================*/

  for(i=0; i<no; i++)
    {
      /* 判断是否要读取点阵数据 */
      if( (i%8)==0 ) bit_dat = *dat++;

      /* 设置相应的点为color或为back_color */
      if( (bit_dat&DCB2HEX_TAB[i&0x07])==0 ) GUI_CopyColor(&bakc, back_color);
      else  GUI_CopyColor(&bakc, disp_color);
      GUI_Point(x, y, bakc);

      if( (++x)>=128 ) return(0);
    }

  return(1);
}

/******************************************************************************************************************
* 函数名称：GUI_LoadBitmap()
* 功    能：输出单色图形数据(位图)。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           dat		要输出显示的数据:横向取模，字节顺序。
*           hno         要显示此行的点个数
*           lno         要显示此列的点个数
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_LoadBitmap(UINT8 x, UINT8 y, UINT8 *dat, UINT8 hno, UINT8 lno)
{
  UINT8  i;

  for(i=0; i<lno; i++)
    {
      GUI_LoadLine(x, y, dat, hno);				   // 输出一行数据
      y++;						           // 显示下一行
      dat += (hno>>3);					           // 计算下一行的数据
      if( (hno&0x07)!=0 ) dat++;
    }
}

/******************************************************************************************************************
* 函数名称：GUI_LoadBitmapN()
* 功    能：输出单色图形数据(位图)，反色显示。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           dat		要输出显示的数据:横向取模，字节顺序。
*           hno         要显示此行的点个数
*           lno         要显示此列的点个数
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_LoadBitmapN(UINT8 x, UINT8 y, UINT8 *dat, UINT8 hno, UINT8 lno)
{
  UINT8  i;

  GUI_ExchangeColor();						   // 显示色与背景色交换
  for(i=0; i<lno; i++)
    {
      GUI_LoadLine(x, y, dat, hno);				   // 输出一行数据
      y++;							   // 显示下一行
      dat += (hno>>3);						   // 计算下一行的数据
      if( (hno&0x07)!=0 ) dat++;
    }
  GUI_ExchangeColor();
}

/******************************************************************************************************************
* 函数名称：GUI_PutHZ()
* 功    能：显示汉字。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           dat		要输出显示的汉字点阵数据:横向取模，字节顺序。
*           hno         要显示此行的点个数
*           lno         要显示此列的点个数
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_PutHZ(UINT8 x, UINT8 y, UINT8 *dat, UINT8 hno, UINT8 lno)
{
  UINT8  i;

  for(i=0; i<lno; i++)
    {
      GUI_LoadLine(x, y, dat, hno);				   // 输出一行数据
      y++;							   // 显示下一行
      dat += (hno>>3);						   // 计算下一行的数据
      if( (hno&0x07)!=0 ) dat++;
   }
}

/******************************************************************************************************************
* 函数名称：GUI_PutHZN()
* 功    能：显示汉字，反色显示。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           dat		要输出显示的汉字点阵数据:横向取模，字节顺序。
*           hno         要显示此行的点个数
*           lno         要显示此列的点个数
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_PutHZN(UINT8 x, UINT8 y, UINT8 *dat, UINT8 hno, UINT8 lno)
{
  UINT8  i;

  GUI_ExchangeColor();						   // 显示色与背景色交换
  for(i=0; i<lno; i++)
    {
      GUI_LoadLine(x, y, dat, hno);				   // 输出一行数据
      y++;							   // 显示下一行
      dat += (hno>>3);						   // 计算下一行的数据
      if( (hno&0x07)!=0 ) dat++;
   }
  GUI_ExchangeColor();						   // 显示色与背景色交换
}

extern __code const UINT8 Font16x16[];
extern __code const UINT8 Font16x16_TAB[];
extern __code const UINT8 BLANK[];
/******************************************************************************************************************
* 函数名称：GUI_PutHZ_By_TAB()
* 功    能：根据用户建立的汉字索引表显示汉字。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           dat		要输出显示的汉字点阵数据:横向取模，字节顺序。
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_PutHZ_By_TAB(UINT8 x,UINT8 y,UINT8 ch[])
{
  UINT16 wm,ii,jj;
  UINT32 adder;

  wm = 0;
  ii = 0;
  jj = 0;
  adder = 1;

  while(Font16x16_TAB[wm] > 100)
    {
      if(Font16x16_TAB[wm] == ch[ii])
       {
         if(Font16x16_TAB[wm + 1] == ch[ii + 1])
          {
            adder = jj * 32;                   // 找到汉字，取出该汉字在索引表中的位置
            break;
          }
       }
      jj++;
      wm +=2;
    }

  if(adder != 1)                               // 找到汉字，显示该汉字
   {
     GUI_PutHZ(x, y,(UINT8 *)(Font16x16+adder), 16, 16);
   }
  else                                         // 找不到汉字，显示空格
   {
     GUI_PutHZ(x, y,(UINT8 *)BLANK, 16, 16);
   }

}

/******************************************************************************************************************
* 函数名称：GUI_PutChar5_7()
* 功    能：显示5*7字体ASCII码，显示值为20H-7FH(若为其它值，则显示' ')。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           ch		要显示的ASCII码值。
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。
* 说    明：操作失败原因是指定地址超出有效范围。(显示格式为6*8)
*******************************************************************************************************************/
UINT8 GUI_PutChar5_7(UINT8 x, UINT8 y, UINT8 ch)
{
  UINT8   font_dat;
  UINT8   i, j;
  UINT8   bakc;

  /* 参数过滤 */
  /*======================================================================================*/
  if( x>=(128-8) ) return(0);                                      // x坐标越界
  if( y>=(64-8) ) return(0);                                       // y坐标越界
  if( (ch<0x20) || (ch>0x7f) ) ch = 0x20;                          // ASCII码值不在20H-7FH范围，显示' '
  /*======================================================================================*/

  ch -= 0x20;
  for(i=0; i<8; i++)
    {
      /* 读取点阵数据 */
      font_dat = FONT5x7ASCII[ch][i];

      for(j=0; j<6; j++)
        {
          /* 设置相应的点为color或为back_color */
          if( (font_dat&DCB2HEX_TAB[j])==0 ) GUI_CopyColor(&bakc, back_color);
          else  GUI_CopyColor(&bakc, disp_color);
          GUI_Point(x, y, bakc);
          x++;
        }

      y++;					                 // 指向下一行
      x -= 6;	                                                 // 恢复x值
    }

  return(1);
}

/******************************************************************************************************************
* 函数名称：GUI_PutString5_7()
* 功    能：输出显示5*7字体ASCII码字符串(没有自动换行功能)。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           str		要显示的ASCII码字符串
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_PutString5_7(UINT8 x, UINT8 y, char *str)
{
  while(1)
      {
        if( (*str)=='\0' ) break;
        if( GUI_PutChar5_7(x, y, *str++)==0 ) break;
        x += 6;						           // 下一个字符显示位置，y不变(即不换行)
      }
}

/******************************************************************************************************************
* 函数名称：GUI_PutNoString5_7()
* 功    能：输出显示5*7字体ASCII码字符串(没有自动换行功能)，若显示的字符个数大于指定个数，则只显示指定个数的字符。
* 入口参数：x		指定显示位置，x坐标
*           y		指定显示位置，y坐标
*           str		要显示的ASCII码字符串
*           no          最大显示字符的个数
* 出口参数：无
* 说    明：操作失败原因是指定地址超出有效范围。
*******************************************************************************************************************/
void GUI_PutNoString5_7(UINT8 x, UINT8 y, char *str, UINT8 no)
{
  if(no==0) return;
  for(; no>0; no--)
    {
      if( (*str)=='\0' ) break;
      if( GUI_PutChar5_7(x, y, *str++)==0 ) break;
      x += 6;							   // 下一个字符显示位置，y不变(即不换行)
    }
}


